@article{10.1145/1013208.1013209,
  author =       {Johnston, Wesley M. and Hanna, J. R. Paul and Millar, Richard
                  J.},
  title =        {Advances in Dataflow Programming Languages},
  year =         2004,
  issue_date =   {March 2004},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       36,
  number =       1,
  issn =         {0360-0300},
  url =          {https://doi.org/10.1145/1013208.1013209},
  doi =          {10.1145/1013208.1013209},
  abstract =     {Many developments have taken place within dataflow programming
                  languages in the past decade. In particular, there has been a
                  great deal of activity and advancement in the field of
                  dataflow visual programming languages. The motivation for this
                  article is to review the content of these recent developments
                  and how they came about. It is supported by an initial review
                  of dataflow programming in the 1970s and 1980s that led to
                  current topics of research. It then discusses how dataflow
                  programming evolved toward a hybrid von Neumann dataflow
                  formulation, and adopted a more coarse-grained approach.
                  Recent trends toward dataflow visual programming languages are
                  then discussed with reference to key graphical dataflow
                  languages and their development environments. Finally, the
                  article details four key open topics in dataflow programming
                  languages.},
  journal =      {ACM Comput. Surv.},
  month =        mar,
  pages =        {1â€“34},
  numpages =     34,
  keywords =     {co-ordination languages, Dataflow, software engineering,
                  graphical programming, multithreading, component software,
                  data flow visual programming}
}

@article{381846,
  author =       {E. A. {Lee} and T. M. {Parks}},
  journal =      {Proceedings of the IEEE},
  title =        {Dataflow process networks},
  year =         1995,
  volume =       83,
  number =       5,
  pages =        {773-801},
  doi =          {10.1109/5.381846}
}

@article{4785860,
  author =       {G. E. {Moore}},
  journal =      {IEEE Solid-State Circuits Society Newsletter},
  title =        {Cramming more components onto integrated circuits, Reprinted
                  from Electronics, volume 38, number 8, April 19, 1965, pp.114
                  ff.},
  year =         2006,
  volume =       11,
  number =       3,
  pages =        {33-35},
  doi =          {10.1109/N-SSC.2006.4785860}
}

@inproceedings{DBLP:conf/ifip/Kahn74,
  author =       {Gilles Kahn},
  editor =       {Jack L. Rosenfeld},
  title =        {The Semantics of a Simple Language for Parallel Programming},
  booktitle =    {Information Processing, Proceedings of the 6th {IFIP} Congress
                  1974, Stockholm, Sweden, August 5-10, 1974},
  pages =        {471--475},
  publisher =    {North-Holland},
  year =         1974,
  timestamp =    {Fri, 17 Jan 2020 19:17:14 +0100},
  biburl =       {https://dblp.org/rec/conf/ifip/Kahn74.bib},
  bibsource =    {dblp computer science bibliography, https://dblp.org}
}

@article{SVENNINGSSON2015143,
  title =        {Combining deep and shallow embedding of domain-specific
                  languages},
  journal =      {Computer Languages, Systems \& Structures},
  volume =       44,
  pages =        {143-165},
  year =         2015,
  note =         {SI: TFP 2011/12},
  issn =         {1477-8424},
  doi =          {https://doi.org/10.1016/j.cl.2015.07.003},
  url =
                  {https://www.sciencedirect.com/science/article/pii/S1477842415000500},
  author =       {Josef Svenningsson and Emil Axelsson},
  keywords =     {Domain specific languages, Shallow embedding, Deep embedding,
                  Fusion, Monads},
  abstract =     {We present a technique to combine deep and shallow embedding
                  in the context of compiling embedded languages in order to
                  provide the benefits of both techniques. When compiling
                  embedded languages it is natural to use an abstract syntax
                  tree to represent programs. This is known as a deep embedding
                  and it is a rather cumbersome technique compared to other
                  forms of embedding, typically leading to more code and being
                  harder to extend. In shallow embeddings, language constructs
                  are mapped directly to their semantics which yields more
                  flexible and succinct implementations. But shallow embeddings
                  are not well-suited for compiling embedded languages. Our
                  technique uses a combination of deep and shallow embedding,
                  which helps keeping the deep embedding small and makes
                  extending the embedded language much easier. The technique
                  also has some unexpected but welcome secondary effects. It
                  provides fusion of functions to remove intermediate results
                  for free without any additional effort. It also helps us to
                  give the embedded language a more natural programming
                  interface.}
}

@misc{bentley_2020,
  title =        {The end of Moore's Law: what happens next?},
  url =
                  {https://www.sciencefocus.com/future-technology/when-the-chips-are-down/},
  journal =      {BBC Science Focus Magazine},
  author =       {Bentley, Dr Peter},
  year =         2020,
  month =        {Apr}
}

@misc{hermans2011breviz,
  title =        {Breviz: Visualizing Spreadsheets using Dataflow Diagrams},
  author =       {Felienne Hermans and Martin Pinzger and Arie van Deursen},
  year =         2011,
  eprint =       {1111.6895},
  archivePrefix ={arXiv},
  primaryClass = {cs.SE}
}

@article{mcbride2011functional,
  title =        {Functional pearl: Kleisli arrows of outrageous fortune},
  author =       {McBride, Conor},
  journal =      {Journal of Functional Programming (accepted for publication)},
  year =         2011
}

@article{parsley,
  author =       {Willis, Jamie and Wu, Nicolas and Pickering, Matthew},
  title =        {Staged Selective Parser Combinators},
  year =         2020,
  issue_date =   {August 2020},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       4,
  number =       {ICFP},
  url =          {https://doi.org/10.1145/3409002},
  doi =          {10.1145/3409002},
  abstract =     {Parser combinators are a middle ground between the fine
                  control of hand-rolled parsers and the high-level almost
                  grammar-like appearance of parsers created via parser
                  generators. They also promote a cleaner, compositional design
                  for parsers. Historically, however, they cannot match the
                  performance of their counterparts. This paper describes how to
                  compile parser combinators into parsers of hand-written
                  quality. This is done by leveraging the static information
                  present in the grammar by representing it as a tree. However,
                  in order to exploit this information, it will be necessary to
                  drop support for monadic computation since this generates
                  dynamic structure. Selective functors can help recover lost
                  functionality in the absence of monads, and the parser tree
                  can be partially evaluated with staging. This is implemented
                  in a library called Parsley.},
  journal =      {Proc. ACM Program. Lang.},
  month =        aug,
  articleno =    120,
  numpages =     30,
  keywords =     {parsers, meta-programming, combinators}
}

@misc{quartz,
  title =        {Quartz Composer User Guide},
  url =
                  {https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/QuartzComposerUserGuide/qc_intro/qc_intro.html#//apple_ref/doc/uid/TP40005381},
  journal =      {Introduction to Quartz Composer User Guide},
  publisher =    {Apple Inc},
  year =         2007,
  month =        {Jul}
}

@misc{tableauPrep,
  title =        {Tableau Prep Builder \& Prep Conductor: A self-service data
                  preparation solution},
  url =          {https://www.tableau.com/en-gb/products/prep},
  journal =      {GitHub},
  author =       {Tableau},
  year =         2021
}

@misc{wadler_1998,
  url =
                  {https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt},
  title =        {The Expression Problem},
  author =       {Wadler, Phillip},
  year =         1998,
  month =        {Nov}
}

@misc{wuYoda,
  title =        {Yoda: A simple combinator library},
  url =          {https://github.com/zenzike/yoda},
  journal =      {GitHub},
  author =       {Wu, Nicolas},
  year =         2018
}
